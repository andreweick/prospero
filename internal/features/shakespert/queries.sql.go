// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package shakespert

import (
	"context"
	"database/sql"
)

const getWork = `-- name: GetWork :one
SELECT w.WorkID, w.Title, w.LongTitle, w.ShortTitle, w.Date, w.GenreType, g.GenreName, w.Notes, w.Source, w.TotalWords, w.TotalParagraphs
FROM Works w
LEFT JOIN Genres g ON w.GenreType = g.GenreType
WHERE w.WorkID = ?
`

type GetWorkRow struct {
	Workid          string
	Title           sql.NullString
	Longtitle       sql.NullString
	Shorttitle      sql.NullString
	Date            sql.NullInt64
	Genretype       sql.NullString
	Genrename       sql.NullString
	Notes           []byte
	Source          sql.NullString
	Totalwords      sql.NullInt64
	Totalparagraphs sql.NullInt64
}

func (q *Queries) GetWork(ctx context.Context, workid string) (GetWorkRow, error) {
	row := q.db.QueryRowContext(ctx, getWork, workid)
	var i GetWorkRow
	err := row.Scan(
		&i.Workid,
		&i.Title,
		&i.Longtitle,
		&i.Shorttitle,
		&i.Date,
		&i.Genretype,
		&i.Genrename,
		&i.Notes,
		&i.Source,
		&i.Totalwords,
		&i.Totalparagraphs,
	)
	return i, err
}

const getWorkChapters = `-- name: GetWorkChapters :many
SELECT ChapterID, Section, Chapter, Description
FROM Chapters
WHERE WorkID = ?
ORDER BY Section, Chapter
`

type GetWorkChaptersRow struct {
	Chapterid   int64
	Section     sql.NullInt64
	Chapter     sql.NullInt64
	Description sql.NullString
}

func (q *Queries) GetWorkChapters(ctx context.Context, workid sql.NullString) ([]GetWorkChaptersRow, error) {
	rows, err := q.db.QueryContext(ctx, getWorkChapters, workid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorkChaptersRow
	for rows.Next() {
		var i GetWorkChaptersRow
		if err := rows.Scan(
			&i.Chapterid,
			&i.Section,
			&i.Chapter,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkCharacters = `-- name: GetWorkCharacters :many
SELECT DISTINCT c.CharID, c.CharName, c.Description, c.SpeechCount
FROM Characters c
WHERE c.Works LIKE '%' || ? || '%'
ORDER BY c.CharName
`

type GetWorkCharactersRow struct {
	Charid      string
	Charname    sql.NullString
	Description sql.NullString
	Speechcount sql.NullInt64
}

func (q *Queries) GetWorkCharacters(ctx context.Context, dollar_1 sql.NullString) ([]GetWorkCharactersRow, error) {
	rows, err := q.db.QueryContext(ctx, getWorkCharacters, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorkCharactersRow
	for rows.Next() {
		var i GetWorkCharactersRow
		if err := rows.Scan(
			&i.Charid,
			&i.Charname,
			&i.Description,
			&i.Speechcount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorksByGenre = `-- name: GetWorksByGenre :many
SELECT w.WorkID, w.Title, w.LongTitle, w.Date, w.GenreType, g.GenreName, w.TotalWords, w.TotalParagraphs
FROM Works w
LEFT JOIN Genres g ON w.GenreType = g.GenreType
WHERE w.GenreType = ?
ORDER BY w.Title
`

type GetWorksByGenreRow struct {
	Workid          string
	Title           sql.NullString
	Longtitle       sql.NullString
	Date            sql.NullInt64
	Genretype       sql.NullString
	Genrename       sql.NullString
	Totalwords      sql.NullInt64
	Totalparagraphs sql.NullInt64
}

func (q *Queries) GetWorksByGenre(ctx context.Context, genretype sql.NullString) ([]GetWorksByGenreRow, error) {
	rows, err := q.db.QueryContext(ctx, getWorksByGenre, genretype)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorksByGenreRow
	for rows.Next() {
		var i GetWorksByGenreRow
		if err := rows.Scan(
			&i.Workid,
			&i.Title,
			&i.Longtitle,
			&i.Date,
			&i.Genretype,
			&i.Genrename,
			&i.Totalwords,
			&i.Totalparagraphs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGenres = `-- name: ListGenres :many
SELECT GenreType, GenreName
FROM Genres
ORDER BY GenreName
`

func (q *Queries) ListGenres(ctx context.Context) ([]Genre, error) {
	rows, err := q.db.QueryContext(ctx, listGenres)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Genre
	for rows.Next() {
		var i Genre
		if err := rows.Scan(&i.Genretype, &i.Genrename); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorks = `-- name: ListWorks :many
SELECT w.WorkID, w.Title, w.LongTitle, w.Date, w.GenreType, g.GenreName, w.TotalWords, w.TotalParagraphs
FROM Works w
LEFT JOIN Genres g ON w.GenreType = g.GenreType
ORDER BY w.Title
`

type ListWorksRow struct {
	Workid          string
	Title           sql.NullString
	Longtitle       sql.NullString
	Date            sql.NullInt64
	Genretype       sql.NullString
	Genrename       sql.NullString
	Totalwords      sql.NullInt64
	Totalparagraphs sql.NullInt64
}

func (q *Queries) ListWorks(ctx context.Context) ([]ListWorksRow, error) {
	rows, err := q.db.QueryContext(ctx, listWorks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWorksRow
	for rows.Next() {
		var i ListWorksRow
		if err := rows.Scan(
			&i.Workid,
			&i.Title,
			&i.Longtitle,
			&i.Date,
			&i.Genretype,
			&i.Genrename,
			&i.Totalwords,
			&i.Totalparagraphs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
